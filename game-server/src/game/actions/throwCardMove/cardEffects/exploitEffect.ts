import { InfrastructureCard, InfrastructureState } from 'shared-types/game.types';
import { Card, AttackVector, Vulnerability } from 'shared-types/card.types';

/**
 * Apply exploit card effect to target infrastructure
 */
export function exploitEffect(
  currentInfra: InfrastructureCard,
  infraIndex: number,
  updatedInfrastructure: InfrastructureCard[],
  card: Card,
  attackVector?: AttackVector,
  playerID?: string
): InfrastructureCard[] {
  if (!attackVector) {
    return updatedInfrastructure;
  }
  
  console.log(`Processing exploit card on infrastructure ${currentInfra.id} (${currentInfra.name}) with current state: ${currentInfra.state}`);
  
  // Make a copy of the infrastructure array
  const newInfrastructure = [...updatedInfrastructure];
  
  // Handle different infrastructure states
  if (currentInfra.state === 'fortified') {
    console.log(`Weakening fortified infrastructure ${currentInfra.name} to fortified_weaken state`);
    // First exploit hit on fortified infrastructure weakens it but doesn't make it vulnerable yet
    newInfrastructure[infraIndex] = {
      ...currentInfra,
      state: 'fortified_weaken' as InfrastructureState
    };
  } 
  else if (currentInfra.state === 'fortified_weaken') {
    console.log(`Second exploit hit on weakened fortified infrastructure ${currentInfra.name}, making it vulnerable`);
    
    // Initialize the vulnerabilities array
    let vulnArray: (string | Vulnerability)[] = [];
    
    // Handle the case where vulnerabilities might be undefined or not an array
    if (currentInfra.vulnerabilities) {
      if (Array.isArray(currentInfra.vulnerabilities)) {
        vulnArray = [...currentInfra.vulnerabilities];
      }
    }
    
    // Add the simple string vulnerability
    vulnArray.push(attackVector);
    
    // Add the full vulnerability object
    const fullVulnerability: Vulnerability = {
      vector: attackVector,
      appliedBy: card.id,
      appliedByPlayer: playerID || '',
      timestamp: Date.now()
    };
    vulnArray.push(fullVulnerability);
    
    // Replace the infrastructure in the array - second hit removes fortification and makes it vulnerable
    newInfrastructure[infraIndex] = {
      ...currentInfra,
      vulnerabilities: vulnArray,
      state: 'vulnerable' as InfrastructureState
    };
  }
  else if (currentInfra.state === 'secure') {
    console.log(`Adding vulnerability with vector: ${attackVector} to infrastructure ${currentInfra.id} (${currentInfra.name})`);
    
    // Create both a simple string vulnerability and a complete vulnerability object
    const simpleVulnerability = attackVector;
    
    // Initialize the vulnerabilities array
    let vulnArray: (string | Vulnerability)[] = [];
    
    // Handle the case where vulnerabilities might be undefined or not an array
    if (currentInfra.vulnerabilities) {
      if (Array.isArray(currentInfra.vulnerabilities)) {
        // Make a copy of the existing array
        vulnArray = [...currentInfra.vulnerabilities];
      }
    }
    
    // Always add a simple string vulnerability for maximum compatibility
    vulnArray.push(simpleVulnerability);
    
    // Also add a full vulnerability object for future-proofing
    const fullVulnerability: Vulnerability = {
      vector: attackVector,
      appliedBy: card.id,
      appliedByPlayer: playerID || '',
      timestamp: Date.now()
    };
    vulnArray.push(fullVulnerability);
    
    console.log(`Infrastructure ${currentInfra.id} vulnerabilities after update:`, vulnArray);
    
    // Create a new infra object with updated state and vulnerabilities
    newInfrastructure[infraIndex] = {
      ...currentInfra,
      vulnerabilities: vulnArray,
      state: 'vulnerable' as InfrastructureState
    };
  }
  
  return newInfrastructure;
}
